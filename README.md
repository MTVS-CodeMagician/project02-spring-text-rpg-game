# Spring을 이용한 Text-RPG 구현 
# "몬스터를 패자" "Defeat the monster"

<br/>

## 기술스택

### Language
<img src="https://img.shields.io/badge/JAVA-007396?style=flat&logo=Java&logoColor=white">

### Framework
<img src="https://img.shields.io/badge/spring-6DB33F?style=flat&logo=spring&logoColor=white">

### Tool
<img src="https://img.shields.io/badge/intellijidea-000000?style=flat&logo=intellijidea&logoColor=white">

<br/><br/>

## 프로젝트 소개
- 텍스트 기반 RPG GAME
- 사용자가 몬스터를 잡으며 성장하는 게임
- Spring 프레임워크와 CQRS 아키텍처 기반으로 제작되었습니다.

<br/>

## 게임의 기본 정보
- 게임 시작 시 사용자의 레벨은 1 입니다.
- 초기 시작은 마을입니다.
- 사용자는 마을에서 자신의 레벨과 보유하고 있는 경험치스톤의 갯수를 확인할 수 있습니다.
- 마을에서는 배틀필드로 이동할 수 있습니다.
- BattleField에서는 몬스터가 랜덤으로 출현합니다.
- 사용자는 BattleField에서 몬스터를 잡아 경험치스톤을 획득하고, 레벨업을 진행합니다.
- 사용자의 레벨이 10에 달성하게 되면 게임은 종료됩니다.

<br/>

## Flow Chart
![image](https://github.com/MTVS-CodeMagician/project02-spring-text-rpg-game/assets/136250818/4e974ba1-9e22-4583-952f-61e4e63240b3)


<br/><br/>

<br/>

## 사용자에 대한 정보
- 시작시 이름을 설정할 수 있다. 한국어 단어로만 작성할 수 있으며, 2자 ~ 5자 이내이다.
- 사용자의 초기 레벨은 1이다.
- 사용자의 초기 경험치스톤 보유량은 0개이다.
- 몬스터 공격시 성공 확률은 75%이다.
- 경험치스톤을 3개 이상 획득시 레벨업하며, 보유하고 있던 경험치스톤을 모두 초기화됩니다.
- 사용자 레벨이 10에 달성할 시 게임은 종료된다.

<br/>

## 몬스터에 대한 정보
- 몬스터의 종류는 3가지이다.
- 배틀필드에만 등장하며, 랜덤으로 한마리만 출현합니다.
- A몬스터에 대한 정보 : A몬스터의 공격 성공 확률은 25%이다. A몬스터가 사용자에게 패배할 시 사용자에게 경험치스톤을 1개 지급한다.
- B몬스터에 대한 정보 : B몬스터의 공격 성공 확률은 50%이다. B몬스터가 사용자에게 패배할 시 사용자에게 경험치스톤을 2개 지급한다.
- C몬스터에 대한 정보 : C몬스터의 공격 성공 확률은 85%이다. C몬스터가 사용자에게 패배할 시 사용자에게 경험치스톤을 3개 지급한다.

<br/><br/>

## 구체적인 게임 진행 소개
- 사용자는 해당 캐릭터에 이름을 설정하는 즉시 게임이 시작되며, 초기 장소는 마을이다.
- 사용자는 마을에서 경험치스톤과 레벨을 확인할 수 있으며, 배틀필드로 이동할 수 있다.
- 마을에서는 '배틀필드로 이동하겠습니까'라는 문구가 나타납니다. Y를 누르면 배틀필드로, N를 누르면 마을로 이동합니다.
- 배틀필드에서는 몬스터가 랜덤으로 출현합니다.
- 몬스터의 종류는 A, B,C가 있으며, 몬스터마다 공격 성공 확률과 보유 경험치 스톤은 다릅니다.
- 배틀필드에서는 사용자와 몬스터가 한번씩 번갈아가며 공격할 수 있으며, 항상 사용자가 선공격한다.
- 공격에 3번 성공하는 쪽이 이긴다.
- 사용자가 공격에 성공할 시 "사용자 공격 성공!" 메세지가 콘솔에 출력되며, 사용자에게 공격 성공한 횟수를 추가한다. (예시. 1/3, 2/3, 3/3)
- 몬스터가 공격에 성공할 시 "몬스터에게 공격받았다!" 메세지가 콘솔에 출력되며, 몬스터의 공격 성공한 횟수를 추가한다.  (예시. 1/3, 2/3, 3/3)
- 사용자가 공격에 실패할 시 "사용자 공격 실패!" 메세지가 콘솔에 출력되며, 사용자의 남은 성공 횟수와 전체 횟수를 출력합니다. (예시. 1/3, 2/3, 3/3)
- 몬스터가 공격에 실패할 시 "몬스터는 공격에 실패했다!" 메세지가 출력되며, 몬스터의 남은 성공 횟수와 전체 횟수를 출력합니다. (예시. 1/3, 2/3, 3/3)
- 몬스터가 이기면(사용자가 지면) 사용자에게 "패배하였습니다" 라는 메세지를 띄우며, 마을로 이동합니다.
    -  경기에서 지고 이기고만 있을 뿐, 사용자가 죽거나 게임이 종료되는 것은 없다.
- 몬스터가 지면(사용자가 이기면) 사용자에게 "승리하였습니다!" 라는 메세지를 띄움과 동시에 해당 몬스터가 가지고 있는 경험치스톤을 획득합니다.
- 경험치 스톤을 획득 후, 3개 이상 보유시 즉시 레벨이 오르고, 보유하고 있는 모든 스톤은 소멸한다.
- 레벨이 9 이하면 마을로 자동으로 이동한다.
- 하지만, 사용자의 레벨이 10에 달성할 시 게임은 종료되며, "게임이 끝났습니다" 메세지를 콘솔에 출력합니다.
- 경험치스톤은 레벨이 오르기 전까지는 계속 보유할 수 있다.
- 배틀필드에서 경기가 끝나면 서로 공격 성공, 실패에 대한 정보는 초기화된다.


<br/><br/>

## 요구사항
- 사용자 : 이름, 레벨, 배틀 필드에서 이기고 지는 조건, 공격성공확률, 현재 보유하고 있는 경험치스톤, 배틀필드에서 공격 성공 횟수.
- 몬스터 : 몬스터종류 3가지, 배틀 필드에서 이기고 지는 조건, 공격성공확률, 가지고 있는 경험치스톤, 배틀필드에서 공격 성공 횟수.
- 마을 : 사용자의 레벨과 보유하고 있는 경험치스톤을 확인할 수 있다. 배틀필드로 이동할 수 있다. 콘솔창에서 Y를 누르면 배틀필드로 이동할 수 있고, N를 누르면 마을에 남아 사용자의 정보를 다시 확인할 수 있다.
- 배틀필드 : 사용자와 몬스터가 대결하는 장소이다. 사용자와 몬스터의 공격 성공 횟수가 나타난다. 경기가 끝나면 레벨업 확인 후 마을로 자동으로 이동한다.


<br/>


## 디렉토리 구조
```
/src/main
├── application                      사용자가 파일을 실행하면서 여러 로직들이 조합
│   ├── controller                   사용자의 요청을 받아 각 서비스에 전달, 응답을 뷰에 전달
│   ├── service                      도메인 서비스의 로직들을 조합하여 기능을 실행
│   ├── view                         사용자가 요청을 보내고 응답을 받는 화면. 여기서는 콘솔의 역할
├── domain                           Entity, Repository 관리 - DB 테이블과 entity를 1:1 매칭
│   ├── entity                       DB의 데이터를 조회하는 로직
│   ├── repository                   DB에 데이터가 저장되기 전에 검증하는 로직 및 테스트를 위해 초기화 하는 로직 구현
│   └── service                      각 객체의 개별적인 기능을 하는 로직
├── dto                              객체 정보 정의
├── infra                            #infra
└────── database                     데이터베이스
/src/test
└── test                             테스트코드 관련 설정 파일

``` 

## 테스트
```
1. Domain의 UserRepositoryTest        사용자의 이름을 입력받을 때 2~5글자 사이고, 한글이 아닌 숫자, 특수문자 등이 들어갈 때 IllegalArgumentException 발생하는지 확인.
2. service의 MonsterCServiceTest      몬스터의 공격 성공 확률이 80%인지 확인.
3. service의 UserServiceTest          스톤의 갯수가 3 이상이면, 레벨이 오르는지 확인.
``` 

<br/>


## 제약사항
- 가독성 있는 코드로 작성할 수 있도록 할 것
- 메소드 이름은 반드시 명령문 형태로 작성
- 테스트 메소드는 충분히 기능을 검증하도록 작성
- 개인 구현은 반드시 브랜치를 생성 후 구현할 것
  (브랜치 이름은 신규인 경우 feature/기능명 형태로 작성할 것)
- 모든 개인 작업이 끝난 후 PR 생성
- PR에 모든 팀원이 코드 리뷰할 것
- 마지막 리뷰어는 Merge 수행하기.
